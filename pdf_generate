from django.views import View
from django.shortcuts import render, redirect
from .models import MyDB
from django.contrib import messages
from django.http import HttpResponseRedirect
from django.contrib.auth import authenticate,login, logout
from django.contrib.auth.forms import AuthenticationForm
from django.shortcuts import get_object_or_404
from .forms import MyDBForm
from django.http import Http404
from django.http import HttpResponse
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.pagesizes import letter, landscape, A4
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.pdfgen import canvas
from io import BytesIO
from reportlab.lib.units import mm

class Home(View):
    template_name = 'home1.html'

    def get(self, request, *args, **kwargs):
        data = MyDB.objects.order_by('-created_date')

        self.data = {

            'data' : data,

        }

        return render(request, self.template_name, self.data)



    def post(self, request, **kwargs):

        # if request.method == 'POST':
        #     form = MyDBForm(self.request.POST, self.request.FILES)
        #     files = request.FILES.getlist('file')
        #     print(form)
        #     print(form.errors)
        #     if form.is_valid():
        #         print("hi")
        #         name = request.POST['name']
        #         gender = request.POST['gender']
        #         email = request.POST['email']
        #         for f in files:
        #             file_instance = MyDB.objects.create(name=name, gender=gender, email=email, file=f)
        #             file_instance.save()
        #         form.save()
        #         return redirect('home/')
        #     else:
        #         raise Http404
        # else:
        #     return render(
        #         request,
        #         self.template_name,
        #         {}
        # )
        if request.method == 'POST':
            name = request.POST['name']
            gender = request.POST['gender']
            email = request.POST['email']
            file = request.FILES.getlist('file')
            for f in file:
                mydb = MyDB.objects.create(name=name, gender=gender, email=email, file=f)


            messages.success(request, "Your Query Has Been Submitted!!!! We Will Get Back To You")
            return redirect("/home")

            return render(request, self.template_name,{})


def signin(request):
    if request.user.is_authenticated:
        return redirect('/home')

    if request.method == 'POST':
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)

        if user is not None:
            login(request, user)
            return redirect('home')
        else:
            form = AuthenticationForm()
            return render(request, 'login.html', {'form': form})

    else:
        form = AuthenticationForm()
        return render(request, 'login.html', {'form': form})



def signout(request):
    logout(request)
    return redirect('/home/login')


def update(request):
    return redirect('/home')


def delete(request):
    return redirect('/home')


def getdata(request, id=None):
    instance = get_object_or_404(MyDB, id=id)
    context = {
        'instance': instance
    }
    return render(request, 'home1.html', context)


def generate_report(request):

    # Create the HttpResponse object with the appropriate PDF headers.
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="items.pdf"'

    # Create the PDF object, using the response object as its "file."
    #doc = SimpleDocTemplate(response, pagesize=letter)
    custom_page_size = (4 * inch, 6 * inch)
    doc = SimpleDocTemplate(response, pagesize=custom_page_size)
    elements = []

    # Set up styles
    styles = getSampleStyleSheet()
    title_style = styles['Title']
    subtitle_style = styles['Heading2']
    body_style = styles['BodyText']

    # Add title
    title = Paragraph("Inventory Report", title_style)
    elements.append(title)
    elements.append(Spacer(1, 0.25 * inch))

    # Add subtitle
    subtitle = Paragraph("List of all items in the inventory", subtitle_style)
    elements.append(subtitle)
    elements.append(Spacer(1, 0.25 * inch))

    # Add additional text
    intro_text = Paragraph(
        "This report contains the current inventory details including the item name, quantity, and price.", body_style)
    elements.append(intro_text)
    elements.append(Spacer(1, 0.25 * inch))

    # Query the database for all items
    items = MyDB.objects.all()

    # Create a list of lists for the table data
    data = [['ID', 'Name', 'Gender', 'Email']]
    for item in items:
        data.append([item.id, item.name, item.gender, item.email])

    # Create a Table object
    table = Table(data)

    # Add style to the table
    style = TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ])
    table.setStyle(style)

    # Add the table to the elements
    elements.append(table)

    # Build the PDF
    doc.build(elements)

    return response


def generate_pdf_canvas(request):
    # Create the HttpResponse object with the appropriate PDF headers.
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="items.pdf"'

    # Define custom page size (width x height)
    custom_page_size = (4 * inch, 6 * inch)  # Example size: 8.5 inches by 11 inches (letter size)
    c = canvas.Canvas(response, pagesize=custom_page_size)

    # Add title
    c.setFont("Helvetica-Bold", 24)
    c.drawString(1 * inch, 10 * inch, "Inventory Report")

    # Add subtitle
    c.setFont("Helvetica-Bold", 18)
    c.drawString(1 * inch, 9.5 * inch, "List of all items in the inventory")

    # Add additional text
    c.setFont("Helvetica", 12)
    text = ("This report contains the current inventory details including the item name, "
            "quantity, and price.")
    c.drawString(1 * inch, 9 * inch, text)

    # Draw a line to separate the header from the table
    c.line(1 * inch, 8.75 * inch, 7.5 * inch, 8.75 * inch)

    # Query the database for all items
    items = MyDB.objects.all()

    # Set the starting position for the table
    y_position = 8.5 * inch

    # Create table headers
    c.setFont("Helvetica-Bold", 12)
    c.drawString(1 * inch, y_position, "ID")
    c.drawString(2 * inch, y_position, "Name")
    c.drawString(4 * inch, y_position, "Gender")
    c.drawString(6 * inch, y_position, "Email")

    # Create table rows
    c.setFont("Helvetica", 12)
    for item in items:
        y_position -= 0.3 * inch
        c.drawString(1 * inch, y_position, str(item.id))
        c.drawString(2 * inch, y_position, item.name)
        c.drawString(4 * inch, y_position, str(item.gender))
        c.drawString(6 * inch, y_position, str(item.email))

        # Add a line break for each row if the table goes beyond the bottom of the page
        if y_position < 1 * inch:
            c.showPage()
            y_position = 10.5 * inch
            # Re-add headers after page break
            c.setFont("Helvetica-Bold", 12)
            c.drawString(1 * inch, y_position, "ID")
            c.drawString(2 * inch, y_position, "Name")
            c.drawString(4 * inch, y_position, "Quantity")
            c.drawString(6 * inch, y_position, "Price")
            y_position -= 0.3 * inch

    # Save the PDF
    c.save()

    return response



def generate_multipage_pdf(request):
    # Create a buffer to hold the PDF content
    buffer = BytesIO()

    # Create a canvas object with A4 size
    pdf = canvas.Canvas(buffer, pagesize=A4)  # A4 size in points

    # Define styles for headings, subheadings, and table
    heading_style = ParagraphStyle(
        name='Heading',
        fontName='Helvetica-Bold',
        fontSize=16,
        leading=22,
        spaceBefore=20,
        spaceAfter=10,
        alignment=1,  # Center alignment
        underline=True  # Underline
    )
    subheading_style = ParagraphStyle(
        name='Subheading',
        fontName='Helvetica-Bold',
        fontSize=14,
        leading=18,
        spaceBefore=10,
        spaceAfter=5,
        alignment=1  # Center alignment
    )
    table_style = TableStyle([
        ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
        ('FONT', (0, 0), (-1, 0), 'Helvetica-Bold', 10),  # Bold header row
        ('FONT', (0, 1), (-1, -1), 'Helvetica', 10),  # Regular font for other rows
        ('ALIGN', (0, 0), (-1, -1), 'CENTER')
    ])



    def generate_pdf(data, page_number, num_columns):
        # Get the canvas width and height
        canvas_width, canvas_height = A4

        # Add heading using Paragraph
        heading = Paragraph(f"Heading - Page {page_number}", heading_style)
        w, h = heading.wrap(canvas_width - 40, canvas_height)
        heading.drawOn(pdf, (canvas_width - w) / 2, canvas_height - 40)

        # Add subheading
        subheading = Paragraph("Subheading Text", subheading_style)
        w, h = subheading.wrap(canvas_width - 40, canvas_height - 70)  # Adjust spacing
        subheading.drawOn(pdf, (canvas_width - w) / 2, canvas_height - 70)

        # Calculate dynamic column width
        col_width = (canvas_width - 40) / num_columns  # Adjust the width to fit the page

        # Create and add table
        table = Table(data, colWidths=[col_width] * num_columns, style=table_style)
        table.wrapOn(pdf, canvas_width - 40, canvas_height - 100)  # Adjust based on content above the table
        table_width, table_height = table.wrap(canvas_width - 40, canvas_height - 110)  # Adjusted height
        table.drawOn(pdf, (canvas_width - table_width) / 2, canvas_height - 110 - table_height)  # Adjusted position

    # For Page1
    data_page1 = [
        ['Column 1', 'Column 2', 'Column 3'],
        ['Data 1', 'Data 2', 'Data 3'],
        ['Data 8', 'Data 9', 'Data 10'],
    ]

    # Determine the number of columns
    num_columns1 = len(data_page1[0])
    generate_pdf(data_page1, 1, num_columns1)
    pdf.showPage()  # Create a new page for subsequent content


    # For Page 2
    data_page2 = [
        ['Column 1', 'Column 2', 'Column 3', 'Column 4', 'Column 5', 'Column 6', 'Column 7'],
        ['Data 1', 'Data 2', 'Data 3', 'Data 4', 'Data 5', 'Data 6', 'Data 7'],
        ['Data 8', 'Data 9', 'Data 10', 'Data 11', 'Data 12', 'Data 13', 'Data 14'],
    ]

    # Determine the number of columns
    num_columns2 = len(data_page2[0])
    generate_pdf(data_page2, 2, num_columns2)
    pdf.showPage()  # Create a new page for subsequent content

    # For Page 3
    data_page3 = [
        ['Column 1', 'Column 2', 'Column 3', 'Column 4', 'Column 5', 'Column 6', 'Column 7'],
        ['Data 1', 'Data 2', 'Data 3', 'Data 4', 'Data 5', 'Data 6', 'Data 7'],
        ['Data 8', 'Data 9', 'Data 10', 'Data 11', 'Data 12', 'Data 13', 'Data 14'],
    ]

    # Determine the number of columns
    num_columns3 = len(data_page3[0])
    generate_pdf(data_page3, 3, num_columns3)

    # Close the PDF content
    pdf.save()

    # Set the HTTP response content type and return the PDF
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    response['Content-Disposition'] = 'inline; filename="items.pdf"'
    return response



def generate_id_card_pdf(request):
    # Create a buffer to hold the PDF content
    buffer = BytesIO()

    # Define ID card size
    id_card_width = 85.6 * mm  # Width in millimeters
    id_card_height = 54 * mm   # Height in millimeters

    # Create a canvas object with ID card size
    pdf = canvas.Canvas(buffer, pagesize=(id_card_width, id_card_height))

    # Define styles for the text
    heading_style = ParagraphStyle(
        name='Heading',
        fontName='Helvetica-Bold',
        fontSize=12,
        leading=14,
        alignment=1  # Center alignment
    )
    subheading_style = ParagraphStyle(
        name='Subheading',
        fontName='Helvetica',
        fontSize=10,
        leading=12,
        alignment=1  # Center alignment
    )

    # Content for the ID card
    heading = Paragraph("John Doe", heading_style)
    subheading = Paragraph("Software Engineer", subheading_style)
    additional_info = Paragraph("Company Name", subheading_style)

    # Calculate center positions
    center_x = id_card_width / 2
    center_y = id_card_height / 2

    # Add heading to the ID card
    w, h = heading.wrap(id_card_width - 20, id_card_height)
    heading.drawOn(pdf, (id_card_width - w) / 2, center_y + h)

    # Add subheading to the ID card
    w, h = subheading.wrap(id_card_width - 20, id_card_height)
    subheading.drawOn(pdf, (id_card_width - w) / 2, center_y)

    # Add additional info to the ID card
    w, h = additional_info.wrap(id_card_width - 20, id_card_height)
    additional_info.drawOn(pdf, (id_card_width - w) / 2, center_y - h)

    # Add any additional details or graphics here
    # ...

    pdf.showPage()  # Finalize the page

    # Close the PDF content
    pdf.save()

    # Set the HTTP response content type and return the PDF
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    response['Content-Disposition'] = 'inline; filename="id_card.pdf"'
    return response
